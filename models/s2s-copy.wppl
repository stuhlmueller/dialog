// --------------------------------------------------------------------
// Helpers

var makeCategoricalOneHot = function(vs) {
  return cache(function(v) {
    var i = _.indexOf(vs, v);
    assert.ok(i != -1, "onehot didn't find " + v + " in " + vs);
    var n = vs.length;
    return oneHot(i, n);
  });
};


// --------------------------------------------------------------------
// Data handling

// This returns a list:
// [{ workspace1, action1 }, { workspace2, action2 }, ...]
var parseDialog = function(dialogString) {
  var initEntry = {
    workspace: Workspace([]),
    action: Action({ who: 'A', what: 'INIT' })
  };
  var rawLines = dialogString.split('\n');
  var dialog = reduceLeft(
    function(history, rawLine) {
      var prevEntry = _.last(history);
      var prevWorkspace = prevEntry.workspace;
      var prevAction = prevEntry.action;
      var workspace = prevWorkspace.update(prevAction);
      var action = stringToAction(rawLine);
      var entry = { workspace, action };
      return history.concat([ entry ]);
    },
    [ initEntry ],
    rawLines);
  return dialog;
};

var fileToDialogs = function(filename) {
  var raw = fs.read(filename).trim();
  return map(parseDialog, raw.split('\n\n'));
};

var fileToWords = function(filename) {
  return _.sortBy(_.uniq(fs.read(filename).trim().split(/\s/g)));
};

var loadBabiData = function() {
  var dataPath = '/project/data/'
  var trainingFile = dataPath + 'dialog-babi-task1/dialog-babi-task1-API-calls-trn-workspace.txt';
  var devFile = dataPath + 'dialog-babi-task1/dialog-babi-task1-API-calls-dev-workspace.txt';
  var specialWords = [
    '^', '$',            // start/end markers
    'INIT', 'WAIT',      // action types not in data
    'NO_OUTPUT',         // filler when copy or match word is not available
    'NO_USER_ACTION',    // initial value of lastUserAction
    'NO_WORKSPACE_WORD'
  ];
  var typesAndTokens = [
    { type: 'cuisine', tokens: ['french', 'italian', 'british', 'spanish', 'indian'] },
    { type: 'location', tokens: ['rome', 'london', 'bombay', 'paris', 'madrid'] },
    { type: 'price', tokens: ['cheap', 'moderate', 'expensive'] },
    { type: 'people', tokens: ['two', 'four', 'six', 'eight'] },
  ];
  return {
    training: fileToDialogs(trainingFile),
    dev: fileToDialogs(devFile),
    words: fileToWords(trainingFile).concat(specialWords),
    typesAndTokens
  };
};

var babiData = loadBabiData();

var onehotWords = makeCategoricalOneHot(babiData.words);

var onlyMessages = function(dialogs) {
  return map(function(dialog){
    return reduceLeft(function(entries, entry) {
      if (entry.action.what === "MSG") {
        return entries.concat(entry.action);
      } else {
        return entries;
      }
    }, [], dialog);
  }, dialogs);
};


var main = function(options) {


  // --------------------------------------------------------------------
  // Options

  var batchSize = options.batchsize || 10;
  var latentDim = options.latentDim || 30;
  var recurrent = (options.lstm === false) ? rnn : lstm;
  var maxDecoderSteps = options.maxdecodersteps || 10;
  var stepSize = options.stepsize || .01;

  var vocabDim = babiData.words.length;
  
  
  // --------------------------------------------------------------------
  // Model components

  var getDesiredAction = function(action) {
    if (action.who === 'U') {
      return Action({ who: 'A', what: 'WAIT' });
    } else {
      return action;
    }
  };

  // Decoder

  var decoderLatentNet = recurrent('decoder-recurrent', {
    hdim: latentDim,
    xdim: vocabDim
  });

  var decoderOutputNet = stack([
    softmax,
    affine('decoder-output', {
      in: latentDim,
      out: vocabDim
    })
  ]);

  var shouldStop = function(params) {
    return ((params.decoderSteps === (maxDecoderSteps + 2)) ||
            (_.last(params.outputs) === '$'));
  }

  var decode = function(state, action, useObservations) {

    var recurse = function(x) {  // { state, decoderSteps, outputs, observations }
      if (shouldStop(x)) {
        return wordsToAction(x.outputs.slice(1));
      } else {
        var outputVector = onehotWords(_.last(x.outputs));
        var state = decoderLatentNet(state, outputVector);
        var ps = decoderOutputNet(state);
        var observation = x.observations ? x.observations[0] : '$';
        var outputDist = Categorical({ ps, vs: babiData.words });
        var output = observe(outputDist,
                             useObservations ? observation : undefined,
                             { guide() { return outputDist; } });
        return recurse({
          state,
          decoderSteps: x.decoderSteps + 1,
          observations: x.observations.slice(1),
          outputs: x.outputs.concat([output])
        });
      }
    };

    return recurse({
      state,
      decoderSteps: 0,
      observations: action.toWords().concat('$'),
      outputs: ['^']
    });
    
  };

  // Encoder
  
  var initializeEncoder = function() {
    return param({
      name: 'encoder-init',
      dims: [latentDim, 1]
    });
  };

  var encodeStep = recurrent('encoder-recurrent', {
    hdim: latentDim,
    xdim: vocabDim
  });

  var actionToVectors = function(action) {
    return map(onehotWords, action.toWords().concat(['$']));
  };

  var encode = function(state, action) {
    var vectors = actionToVectors(action);
    return reduceLeft(encodeStep, state, vectors);
  };


  // --------------------------------------------------------------------
  // Main model structure
  
  var model = function(x) {  // { data, callback }
    
    var step = function(state, action) {
      var desiredAction = getDesiredAction(action)
      var modelAction = decode(state, desiredAction, x.useObservations);
      if (x.callback) {
        var callback = x.callback;
        callback({ action, modelAction, desiredAction });
      }
      return encode(state, action);
    };
    
    mapData({ data: x.data, batchSize }, function(dialog) {
      var state = initializeEncoder();
      reduceLeft(step, state, dialog);
    });
    
    return null;
    
  };


  // --------------------------------------------------------------------
  // Inference and optimization

  var runOptimize = function() {
    Optimize({
      model() {
        return model({
          data: onlyMessages(babiData.training),
          useObservations: true
        });
      },
      steps: 100000,
      optMethod: { adam: { stepSize }}
    });
  };

  var runBehavior = function() {
    Infer({
      method: 'forward',
      model() {
        return model({
          data: onlyMessages(babiData.dev.slice(0, 10)),
          useObservations: false,
          callback(x) {  // action, modelAction, desiredAction
            var s = function(maybeAction) {
              return maybeAction ? maybeAction.toString() : 'null';
            }
            if (x.action.who === 'U') {            
              console.log('Want: ', s(x.desiredAction), '(', s(x.action), ')');
            } else {
              console.log('Want: ', s(x.desiredAction));
            }
            console.log('Model:', s(x.modelAction));
            console.log();
          }
        });
      },
      guide: true
    });
  };  
  
  if (options['optimize']) {
    runOptimize();
  } else if (options['behavior']) {
    runBehavior();    
  } else {
    util.fatal('No known command given' )
  }
  
};


main(parseArgs(process.argv));