// --------------------------------------------------------------------
// Helpers

var makeCategoricalOneHot = function(vs) {
  return cache(function(v) {
    var i = _.indexOf(vs, v);
    assert.ok(i != -1, "onehot didn't find " + v + " in " + vs);
    var n = vs.length;
    return oneHot(i, n);
  });
};


// --------------------------------------------------------------------
// Data handling

// This returns a list:
// [{ workspace1, action1 }, { workspace2, action2 }, ...]
var parseDialog = function(dialogString) {
  var initEntry = {
    workspace: Workspace([]),
    action: Action({ who: 'A', what: 'INIT' })
  };
  var rawLines = dialogString.split('\n');
  var dialog = reduceLeft(
    function(history, rawLine) {
      var prevEntry = _.last(history);
      var prevWorkspace = prevEntry.workspace;
      var prevAction = prevEntry.action;
      var workspace = prevWorkspace.update(prevAction);
      var action = stringToAction(rawLine);
      var entry = { workspace, action };
      return history.concat([ entry ]);
    },
    [ initEntry ],
    rawLines);
  return dialog;
};

var fileToDialogs = function(filename) {
  var raw = fs.read(filename).trim();
  return map(parseDialog, raw.split('\n\n'));
};

var fileToWords = function(filename) {
  return _.sortBy(_.uniq(fs.read(filename).trim().split(/\s/g)));
};

var loadBabiData = function() {
  var dataPath = '/project/data/'
  var trainingFile = dataPath + 'dialog-babi-task1/dialog-babi-task1-API-calls-trn-workspace.txt';
  var devFile = dataPath + 'dialog-babi-task1/dialog-babi-task1-API-calls-dev-workspace.txt';
  var specialWords = [
    '^', '$',            // start/end markers
    'INIT', 'WAIT',      // action types not in data
    'NO_OUTPUT',         // filler when copy or match word is not available
    'NO_USER_ACTION',    // initial value of lastUserAction
    'NO_WORKSPACE_WORD'
  ];
  var typesAndTokens = [
    { type: 'cuisine', tokens: ['french', 'italian', 'british', 'spanish', 'indian'] },
    { type: 'location', tokens: ['rome', 'london', 'bombay', 'paris', 'madrid'] },
    { type: 'price', tokens: ['cheap', 'moderate', 'expensive'] },
    { type: 'people', tokens: ['two', 'four', 'six', 'eight'] },
  ];
  return {
    training: fileToDialogs(trainingFile),
    dev: fileToDialogs(devFile),
    words: fileToWords(trainingFile).concat(specialWords),
    typesAndTokens
  };
};

var babiData = loadBabiData();

var onehotWords = makeCategoricalOneHot(babiData.words);

var onlyMessages = function(dialogs) {
  return map(function(dialog){
    return reduceLeft(function(entries, entry) {
      if (entry.action.what === "MSG") {
        return entries.concat(entry.action);
      } else {
        return entries;
      }
    }, [], dialog);
  }, dialogs);
};


var main = function(options) {


  // --------------------------------------------------------------------
  // Options

  var batchSize = options.batchsize || 5;
  var latentDim = options.latentdim || 50;
  var recurrent = (options.lstm === false) ? rnn : lstm;
  var maxDecoderSteps = options.maxdecodersteps || 10;
  var stepSize = options.stepsize || .01;
  var addWaitActions = options.addwaitactions || false;

  var vocabDim = babiData.words.length;
  
  var model = function(x) {  // { data, callbackOnStep, callbackOnDialog, useMAP }

    // --------------------------------------------------------------------
    // Model components

    var getDesiredAction = function(action) {
      if (action.who === 'U') {
        return Action({ who: 'A', what: 'WAIT' });
      } else {
        return action;
      }
    };

    // Decoder

    var initializeDecoder = stack([
      tanh,
      affine('decoder-init', { in: latentDim, out: latentDim })
    ]);
    
    var decoderLatentNet = recurrent('decoder-recurrent', {
      hdim: latentDim,
      xdim: vocabDim
    });

    var decoderOutputNet = stack([
      softmax,
      affine('decoder-output', {
        "in": 2 * latentDim + vocabDim,  // [decState, memState, outputVector]
        "out": vocabDim
      }),
      concat
    ]);

    var shouldStop = function(params) {
      return ((params.decoderSteps === (maxDecoderSteps + 2)) ||
              (_.last(params.outputs) === '$'));
    }

    var attentionMLP = stack([
      toScalar,
      tanh,
      affine('attention-1', { "in": latentDim * 2, "out": 1 }),
      concat
    ]);

    var decode = function(encStates, action, useObservations) {

      var recurse = function(x) {  // { state, decSteps, outputs, observations }
        if (shouldStop(x)) {
          return wordsToAction(x.outputs.slice(1));
        } else {

          var outputVector = onehotWords(_.last(x.outputs));
          var decState = decoderLatentNet(x.decState, outputVector);

          // Attention
          var combineWithDecoderState = function(encState) { return attentionMLP([encState, decState]); };
          var attentionVector = softmax(Vector(map(combineWithDecoderState, encStates)));
          var memState = vectorSum(map2(function(encState, weight) {
            return T.mul(encState, weight);
          }, encStates, T.toScalars(attentionVector)));

          var ps = decoderOutputNet([decState, memState, outputVector]);
          var observation = x.observations ? x.observations[0] : '$';
          var outputDist = Categorical({ ps, vs: babiData.words });
          var output = (
            x.useMAP ?
              outputDist.MAP().val :
              observe(outputDist,
                      useObservations ? observation : undefined,
                      { guide() { return outputDist; } }));
          return recurse({
            decState,
            decSteps: x.decSteps + 1,
            observations: x.observations.slice(1),
            outputs: x.outputs.concat([output])
          });
        }
      };

      return recurse({
        decState: initializeDecoder(_.last(encStates)),
        decSteps: 0,
        observations: action.toWords().concat('$'),
        outputs: ['^']
      });
      
    };

    // Encoder
    
    var initializeEncoder = function() {
      return param({
        name: 'encoder-init',
        dims: [latentDim, 1]
      });
    };

    var encodeStep = recurrent('encoder-recurrent', {
      hdim: latentDim,
      xdim: vocabDim
    });

    var actionToVectors = function(action) {
      return map(onehotWords, action.toWords().concat(['$']));
    };

    var encode = function(state, action) {
      var vectors = actionToVectors(action);
      return reduceLeft(encodeStep, state, vectors);
    };


    // --------------------------------------------------------------------
    // Main model structure
    
    var step = function(encStates, action) {
      var desiredAction = getDesiredAction(action);     
      var modelAction = ((desiredAction.what !== 'WAIT' || addWaitActions) ?
                         decode(encStates, desiredAction, x.useObservations) :
                         desiredAction);
      if (x.callbackOnStep) {
        var callback = x.callbackOnStep;
        callback({ action, modelAction, desiredAction });
      }
      var oldEncState = _.last(encStates);
      var newEncState = encode(oldEncState, action);
      return encStates.concat([newEncState]);
    };
    
    mapData({ data: x.data, batchSize }, function(dialog) {
      var state = initializeEncoder();
      reduceLeft(step, [state], dialog);
      if (x.callbackOnDialog) {
        var callback = x.callbackOnDialog;
        callback();
      }
    });
    
    return null;
    
  };


  // --------------------------------------------------------------------
  // Inference and optimization

  var getAccuracy = function(data) {
    var stats = {
      dialogs: { total: 0, correct: 0 },
      responses: { total: 0, correct: 0 },
      responsesInCurrentDialog: { total: 0, correct: 0 }
    };
    var callbackOnDialog = function() {
      var allCorrect = stats.responsesInCurrentDialog.correct === stats.responsesInCurrentDialog.total;
      _.assign(stats.dialogs, {
        total: stats.dialogs.total + 1,
        correct: stats.dialogs.correct + (allCorrect ? 1 : 0)
      });
      _.assign(stats.responsesInCurrentDialog, { total: 0, correct: 0 })
    };
    var callbackOnStep = function(x) {  // { action, modelAction, desiredAction }
      var isCorrect = x.modelAction && (x.modelAction.toString() === x.desiredAction.toString() + ' $');
      var update = function(obj) {
        _.assign(obj, {
          total: obj.total + 1,
          correct: obj.correct + (isCorrect ? 1 : 0)
        });
      }
      update(stats.responses);
      update(stats.responsesInCurrentDialog);
    };
    Infer({
      method: 'forward',
      samples: 1,
      model() {
        return model({
          data,
          useObservations: false,
          useMAP: true,
          callbackOnDialog,
          callbackOnStep
        });
      }
    });
    return _.pick(stats, ['dialogs', 'responses']);
  };

  var runAccuracy = function(label, data) {
    var formatStat = function(stat) {
      return _.toString(100 * stat.correct / stat.total) + '% correct (' + stat.correct + '/' + stat.total + ')';
    };
    var stats = getAccuracy(data);
    console.log(label);
    console.log('Responses:', formatStat(stats.responses));
    console.log('Dialogs:', formatStat(stats.dialogs));
  };

  var runOptimize = function(data) {
    var startTime = _.now();
    var traceFile = '/data/results/trace.json';
    fs.write(traceFile, '[]');    
    Optimize({
      model() {
        return model({
          data,
          useObservations: true
        });
      },
      steps: 100000,
      optMethod: { adam: { stepSize }},
      onStep(index, objectiveValue) {
        if (index % 200 === 0) {
          var trainingStats = getAccuracy(onlyMessages(babiData.training.slice(0, 200)));
          var devStats = getAccuracy(onlyMessages(babiData.dev.slice(0, 200)));
          var stats = {
            index,
            runtimeInSeconds: (_.now() - startTime) / 1000,
            objectiveValue,
            trainingStats,
            devStats
          };
          runBehavior(onlyMessages(babiData.dev.slice(0, 1)));
          console.log(JSON.stringify(stats, null, 2));
          var trace = JSON.parse(fs.read(traceFile));
          fs.write(traceFile, JSON.stringify(trace.concat(stats)));
        }
      }
    });
  };

  var runBehavior = function(data) {
    Infer({
      method: 'forward',
      samples: 1,
      model() {
        return model({
          data,
          useObservations: false,
          useMAP: true,
          callbackOnStep(x) {  // action, modelAction, desiredAction
            var s = function(maybeAction) {
              return maybeAction ? maybeAction.toString() : 'null';
            }
            if (x.action.who === 'U') {            
              console.log('Want: ', s(x.desiredAction), '(', s(x.action), ')');
            } else {
              console.log('Want: ', s(x.desiredAction));
            }
            console.log('Model:', s(x.modelAction));
            console.log();
          }
        });
      }
    });
  };  
  
  if (options['optimize']) {
    runOptimize(onlyMessages(babiData.training));
  } else if (options['behavior']) {
    runBehavior(onlyMessages(babiData.dev.slice(0, 10)));
  } else if (options['accuracy']) {
    runAccuracy('\nTraining:', onlyMessages(babiData.training.slice(0, 200)));
    runAccuracy('\nDev:', onlyMessages(babiData.dev.slice(0, 200)));    
  } else {
    console.error('No known command given', options)
  }
  
};


main(argv);
